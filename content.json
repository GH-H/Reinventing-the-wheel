{"pages":[{"title":"简历","text":"个人信息 姓名：黄港欢 &emsp;&emsp;&emsp;性 别：男&emsp;&emsp;&emsp;&emsp;年 龄：24 技术博客：https://gh-h.github.io/Reinventing-the-wheel/ Github：https://github.com/GH-H?tab=repositories 微信：h820546005 &emsp;&emsp;&emsp;&emsp; 邮 箱：huangganghuan1@gmail.com 教育经历 华盛顿大学 University of Washington &emsp;&emsp;&emsp;&emsp;&ensp;&emsp;&emsp;&ensp;&emsp;&emsp;&ensp;本科 2019.04 - 2021.06 专 业：计算机科学与系统(Computer Science and Systems)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GPA: 3.37 /4.0 下学期课程(3月学季制)：数据库内部系统，计算机系统 专业技能 熟悉 Java 了解 git,数据库(mysql,sql server)，C 数据结构和算法，计算机网络，计算机原理 项目经历 学校–Java 重构 Pep/8 汇编语言虚拟机–4人Scrum团队敏捷开发模式 具体功能 ：实现27/36个指令。虚拟机附带图形用户界面，可解析十六进制和汇编语言,执行代码并显示cpu和内存数据。 技术难点: 1.团队代码不规范，github代码审查困难。2.需要将27个指令模块化后分配开发任务。3.控制反码，补码以及数据的溢出 4.cpu以及内存设计 5.内存指针跳转 6.代码测试100%覆盖率 等等 个人贡献以及收获：参与设计cpu和内存，以接口和多态拆分指令优化解码。对计算机原理和汇编有进一步的了解，进一步熟悉git管理,团队合作代码审核 github链接： https://github.com/GH-H/Pep-8-simulator 个人-英雄联盟数据库设计-独立开发 具体实现：设计关系型ER 数据库模型 并使用sqlserver 和c#实现用户注册 和 数据库增删查改 技术难点: 实际上用 visual studio 做简易UI，连接数据库难度不高，该项目主要侧重于数据库范式设计的应用和增删查改的优化 github链接： https://github.com/GH-H/MOBA-Game-statistic-Information-Database","link":"/Reinventing-the-wheel/%E7%AE%80%E5%8E%86/index.html"}],"posts":[{"title":"博客简介","text":"博主目前就读于华大(University Of Washing)的本科生一枚。只会造个小轮子，偶尔闲着无聊把笔记搬到博客上，顺便理一下知识点。各位大佬有空可去我github瞄一眼，链接右上角。 什么是造轮子？「造轮子（Reinventing the wheel）」—— 圆形是大家公认的最合适的车轮形状，而有人非要重新再发明一次轮子不但没有意义、浪费时间，还会使其无法投入更有意义及价值的目标。明知道成功的可能微乎其微，而执意去执行的行为就叫造轮子。 为什么要宣扬造轮子精神？殊不知，造轮子是一种学习方式，能快速通过实践提高自身能力。很多事情看起来简单，但只有自己动手，才会发现其中的难点。想要精通计算机，实践必不可免，没有什么人一出身就站在知识的巅峰。而我希望能宣扬这样一个精神 “明知道你做的不可能比前辈做得更好，却仍然坚持要做。” 简而言之不敲代码造轮子我还会个锤子？","link":"/Reinventing-the-wheel/2020/02/02/main/"},{"title":"Java版本","text":"JDk1.1新技术：JAR文件格式，JDBC，JavaBeans,RMI。新语法：内部类(Inner Class) 和反射(Reflection). JDK1.2技术体系拆分：桌面开发J2SE,企业级开发J2EE,移动端开发(J2ME)。新技术：EJB,Java Plug-in,Java IDE,Swing等。虚拟机：新内置JIT编译器其它：stricfp 关键字和Collection集合类 JDK1.3其它：类库改进，Java 2D 新API， 新JavaSound类库 JDK1.4新技术：正则表达式，异常链，NIO，日志类，XML解析器，XSLT转换器 JDK1.5主要为语法易用性改进新语法：自动装箱，泛型，动态注解，枚举，可变长参数，遍历循环(foreach)虚拟机和API：内存模型改进，java.util.comcurrent 并发包 JDK1.6新技术：动态语言支持，API微型HTTP服务器API虚拟机：锁与同步，垃圾收集，类加载 JDK1.7新技术：新G1收集器，加强非Java语言调用支持，升级类加载架构 [回到目录]","link":"/Reinventing-the-wheel/2021/04/06/Java/Java%E7%89%88%E6%9C%AC/"},{"title":"virtualBox 安装Ubuntu","text":"创建新VM，设置参数 安装系统镜像启动VM Add 并选择disk image 后，重启vm并安装 安装完成后弹出镜像盘","link":"/Reinventing-the-wheel/2021/04/03/linux/virtualBox-%E5%AE%89%E8%A3%85Ubuntu/"},{"title":"目录结构","text":"","link":"/Reinventing-the-wheel/2021/03/28/linux/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"title":"导航","text":"Post not found: linux/virtualBox-安装Ubuntu服务器 [virtualBox 安装Ubuntu服务器]","link":"/Reinventing-the-wheel/2021/03/28/linux/%E5%AF%BC%E8%88%AA/"},{"title":"策略模式 Strategy","text":"","link":"/Reinventing-the-wheel/2021/03/24/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy/"},{"title":"单列模式 Singleton","text":"饿汉式 类加载到内存后实列化一个单例，JVM保证线程安全 缺点：不论是否用到，都会在类装载时完成实例化 实用但不完美 12345678910111213141516public class T1 { private static final T1 INSTANCE = new T1(); private T1(){} public static T1 getInstance(){return INSTANCE;} public void m(){ System.out.println(&quot;test&quot;); } public static void main(String[] args) { T1 e1 = T1.getInstance(); T1 e2 = T1.getInstance(); System.out.println(e1 == e2); }} 在其它class里新建一个实列会报错 123456public class Main { public static void main(String[] args) { T1 test = new T1();//error T1 test2 = T1.getInstance(); }} 静态内部类方式 JVM单例 加载外部类时不会加载内部类，可以实现懒加载 最完美 123456789101112131415public class T3 { private T3(){} private static class T3Holder{ private final static T3 INSTANCE = new T3(); } public void m(){ System.out.println(&quot;test&quot;); } public static T3 getInstance(){ return T3Holder.INSTANCE; }} 懒汉式 按需求初始化，加synchronized保证线程安全，但效率下降 相对完美但不实用 1234567891011121314151617181920public class T2 { private static volatile T2 INSTANCE; private T2(){} public void m(){ System.out.println(&quot;test&quot;); } public static T2 getInstance(){ if(INSTANCE == null){ synchronized (T2.class){ if(INSTANCE == null){ INSTANCE = new T2(); } } } return INSTANCE; }} 枚举完美中的完美，可以解决线程同步，防止反序列化 12345678public enum T4 { INSTANCE; public void m(){ System.out.println(&quot;test&quot;); }}","link":"/Reinventing-the-wheel/2021/03/24/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F-Singleton/"},{"title":"平衡二叉树 AVL tree","text":"","link":"/Reinventing-the-wheel/2021/03/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL-tree/"},{"title":"堆排序 heap sort","text":"概述 利用堆(heap)设计的一种选择排序 最坏，最好，平均复杂度为O(nlogn).不稳定排序 堆类似完全二叉树，左右子节点大小顺序无规定 大顶堆每个节点大于其左右子节点， 小顶堆每个节点小于其左右子节点 一般升序大顶堆，降序小顶堆 流程 将数组以最大堆重新排序 将最大值与最小值替换，并移除heap最大值(数组第一位与最后一位交换并缩小范围) 重复1，2直到剩最后一个 public void sort(int arr[]){ int n = arr.length; // Build heap (rearrange array) for (int i = n / 2 - 1; i &gt;= 0; i--) heapify(arr, n, i); // One by one extract an element from heap for (int i = n - 1; i &gt; 0; i--) { // Move current root to end int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; // call max heapify on the reduced heap heapify(arr, i, 0); } } // To heapify a subtree rooted with node i which is // an index in arr[]. n is size of heap void heapify(int arr[], int n, int i) { int largest = i; // Initialize largest as root int l = 2 * i + 1; // left = 2*i + 1 int r = 2 * i + 2; // right = 2*i + 2 // If left child is larger than root if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l; // If right child is larger than largest so far if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r; // If largest is not root if (largest != i) { int swap = arr[i]; arr[i] = arr[largest]; arr[largest] = swap; // Recursively heapify the affected sub-tree heapify(arr, n, largest); } } 假设数组为12 21 13 15 6 17大顶堆数组移动12 21 17 15 6 1312 21 17 15 6 1312 21 17 15 6 1321 12 17 15 6 1321 15 17 12 6 13 替换，重排序，并缩小范围13 15 17 12 6 2117 15 13 12 6 216 15 13 12 17 2115 6 13 12 17 2115 12 13 6 17 216 12 13 15 17 2113 12 6 15 17 216 12 13 15 17 2112 6 13 15 17 216 12 13 15 17 21","link":"/Reinventing-the-wheel/2021/03/23/%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort/"},{"title":"二叉树 Binary Tree","text":"概述 满二叉树和完全二叉树 检索 顺序存储二叉树堆排序会用到 通常只考虑完全二叉树 当前左子节点：2*n+1 当前右子节点：2*n+2 当前父节点: (n-1)/2 以树的三种顺序读取数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class arrToTree{ private int[] arr; public arrToTree(int[] arr) { this.arr = arr; } public void preOrder(int index){ if(arr == null || arr.length == 0){ System.out.println(&quot;empty array&quot;); } System.out.println(arr[index]); if((index*2+1)&lt; arr.length){ preOrder(2*index+1); } if((index*2+2)&lt; arr.length){ preOrder(2*index+2); } } public void inOrder(int index){ if(arr == null || arr.length == 0){ System.out.println(&quot;empty array&quot;); } if((index*2+1)&lt; arr.length){ preOrder(2*index+1); } System.out.println(arr[index]); if((index*2+2)&lt; arr.length){ preOrder(2*index+2); } } public void postOrder(int index){ if(arr == null || arr.length == 0){ System.out.println(&quot;empty array&quot;); } if((index*2+1)&lt; arr.length){ preOrder(2*index+1); } if((index*2+2)&lt; arr.length){ preOrder(2*index+2); } System.out.println(arr[index]); }} 测试 1234567public static void main(String[] args) { int[] arr = {1,2,3,4,5,6,7}; arrToTree tree = new arrToTree(arr); tree.preOrder(0); tree.postOrder(0); tree.inOrder(0); } 线索化二叉树 n个节点的二叉树中有n+1个空指针。 利用空指针存放当前节点前驱和后继节点，称为线索 线索分为前序，中序，后序 left有可能指向左子树而不是前驱 right有可能指向右子树而非后继","link":"/Reinventing-the-wheel/2021/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"JVM 虚拟机","text":"此文章为个人简易备忘录，请参考原著《深入了解java虚拟机》 JVM 简介Java 虚拟机为所有物理机建立了一个统一的运行平台。在任何虚拟机上编译的程序能在任何虚拟机运行，虚拟层面隐藏了底层技术复杂性和操作系统差异性。 优点相比于C/C++,Java 开发主要集中在业务逻辑上而硬件兼容性。因此应用开发更加高效和快捷。 缺点为了给所有硬件提供一致的虚拟平台，Java硬件效能相对得减少。以至于大多数形况下提升硬件性能无法获得同比的性能回报。 为什么需要学习？–深入了解虚拟机的运作原理可以帮助程序员写出具有高度适应性的代码–帮助排查内存错误–自动运作特性可以帮助java程序员成长–对于企业级开发至关重要 内存区域概述对于C/C++开发人员而言，他们拥有对每一个对象的所有权并且要维护一整个生命周期。所以内存泄漏和内存溢出必须时刻关注。 对于JAVA开发人员而言，内存管理机制操作对象生命周期，不容易出现内存泄漏和溢出问题。一旦出现问题排查难度较高。 运行时数据区域JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。 PC寄存器\\未完 注：《深入了解java虚拟机》至 25 页，61 至","link":"/Reinventing-the-wheel/2021/03/04/JVM/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"目录","text":"num.[简介] num.[Java版本]","link":"/Reinventing-the-wheel/2021/03/04/JVM/%E7%9B%AE%E5%BD%95/"},{"title":"BFS VS DFS","text":"","link":"/Reinventing-the-wheel/2020/07/19/%E7%AE%97%E6%B3%95/%E9%AB%98%E9%98%B6/BFS-VS-DFS/"},{"title":"150.逆波兰表达式求值","text":"题123456有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例1234567891011121314151617181920212223示例 1：输入:[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释:该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9示例 2：输入:[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释:该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6示例 3：输入:[&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 中缀表达式 后缀表达式 1+2 1 2 + 2 + 3 * 4 2 3 4 * + 9 + (4 - 1) * 2 9 4 1 - 2 * + 使用栈（非最优解） 用stack栈依次push数值 遇到符号pop两个进行计算 1234567891011121314151617181920212223242526272829303132public static int evalRPN(String[] tokens) { Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;(); Integer op1, op2; for (String s : tokens) { switch (s) { case &quot;+&quot;: op2 = numStack.pop(); op1 = numStack.pop(); numStack.push(op1 + op2); break; case &quot;-&quot;: op2 = numStack.pop(); op1 = numStack.pop(); numStack.push(op1 - op2); break; case &quot;*&quot;: op2 = numStack.pop(); op1 = numStack.pop(); numStack.push(op1 * op2); break; case &quot;/&quot;: op2 = numStack.pop(); op1 = numStack.pop(); numStack.push(op1 / op2); break; default: numStack.push(Integer.valueOf(s)); break; } } return numStack.pop(); } 数组模拟栈1234567891011121314151617181920212223242526public static int evalRPN(String[] tokens) { int[] numStack = new int[tokens.length / 2 + 1]; int index = 0; for (String s : tokens) { switch (s) { case &quot;+&quot;: numStack[index - 2] += numStack[--index]; break; case &quot;-&quot;: numStack[index - 2] -= numStack[--index]; break; case &quot;*&quot;: numStack[index - 2] *= numStack[--index]; break; case &quot;/&quot;: numStack[index - 2] /= numStack[--index]; break; default: // numStack[index++] = Integer.valueOf(s); //valueOf改为parseInt，减少自动拆箱装箱操作 numStack[index++] = Integer.parseInt(s); break; } } return numStack[0]; }","link":"/Reinventing-the-wheel/2020/06/16/%E8%82%9D%E9%A2%98/%E6%A0%88/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"title":"二叉搜索树 Binary search tree","text":"概述1.改善了二叉树节点查找的效率2.左子节点小于当前节点3.右子节点大于当前节点4.可将重复数值放在左或右子节点 优点相比于其他数据结构，查找、插入的时间复杂度较低,均为O(log n)。 先写node 123456789101112131415class Node{ int key; Node left; Node right; public Node(int key) { this.key = key; } @Override public String toString() { return &quot;key=&quot; + key ; }} 删除节点为叶子删除节点有一颗子树删除节点有两棵子树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class BinarySearchTree { Node root; // This method mainly calls insertRec() void add(int key) { root = addNode(root, key); } /* A recursive function to insert a new key in BST */ Node addNode(Node root, int key) { /* If the tree is empty, return a new node */ if (root == null) { root = new Node(key); return root; } /* Otherwise, recur down the tree */ if (key &lt; root.key) root.left = addNode(root.left, key); else if (key &gt; root.key) root.right = addNode(root.right, key); /* return the (unchanged) node pointer */ return root; } public void preOrderTraverse(Node current){ if(current != null){ System.out.println(current); inOrderTraverse(current.left); inOrderTraverse(current.right); } } public void inOrderTraverse(Node current){ if(current != null){ inOrderTraverse(current.left); System.out.println(current); inOrderTraverse(current.right); } } public void postOrderTraverse(Node current){ if(current != null){ inOrderTraverse(current.left); inOrderTraverse(current.right); System.out.println(current); } } public Node findNode(int key){ Node current = root; while(current.key != key){ if(key &lt; current.key){ current = current.left; }else{ current = current.right; } if (current == null){ return null; } } return current; } // This method mainly calls deleteRec() void deleteKey(int key) { root = deleteNode(root, key); } /* A recursive function to delete an existing key in BST */ Node deleteNode(Node root, int key) { /* Base Case: If the tree is empty */ if (root == null) return root; /* Otherwise, recur down the tree */ if (key &lt; root.key) root.left = deleteNode(root.left, key); else if (key &gt; root.key) root.right = deleteNode(root.right, key); // if key is same as root's // key, then This is the // node to be deleted else { // node with only one child or no child if (root.left == null) return root.right; else if (root.right == null) return root.left; // node with two children: Get the inorder // successor (smallest in the right subtree) root.key = minValue(root.right); // Delete the inorder successor root.right = deleteNode(root.right, root.key); } return root; } int minValue(Node root) { int minv = root.key; while (root.left != null) { minv = root.left.key; root = root.left; } return minv; } public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); tree.add(4); tree.add(5); tree.add(3); tree.add(1); tree.add(2); tree.inOrderTraverse(tree.root); //tree.preOrderTraverse(tree.root); //tree.postOrderTraverse(tree.root); }}","link":"/Reinventing-the-wheel/2020/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-Binary-search-tree/"},{"title":"集合 set","text":"概述用于存储无序元素，值不能重复。 重构思路 添加时忽略重复元素 添加内部类，iterator implement iterable 后可以使用for each 重写equal，toString hashcode 暂时忽略 以下为generic构造造轮子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//implement iterable 后可以使用for eachpublic class ArraySet&lt;T&gt; implements Iterable&lt;T&gt;{ private T[] items; private int size; //返回通用iterator public Iterator&lt;T&gt; iterator(){ return new ArraySetIterator(); } //构建通用iterator private class ArraySetIterator implements Iterator&lt;T&gt;{ private int index; public ArraySetIterator(){ index = 0; } public boolean hasNext(){ return index &lt; size; } public T next(){ T returnItem = items[index]; index++; return returnItem; } } public ArraySet(){ items = (T[]) new Object[100]; size = 0; } public boolean contains(T x){ for(int i = 0;i&lt;size;i++){ if(x.equals(items[i])){ return true; } } return false; } public void add(T x){ if(x == null){ throw new IllegalArgumentException(&quot;cannot add null yo the set&quot;); } if(contains(x)){ return; } items[size] = x; size++; } public int size(){ return size; } //toString 重写 @Override public String toString(){ String returnString = &quot;{&quot;; for(T item: this){ returnString += item.toString(); returnString += &quot;, &quot;; return returnString; } returnString += items[size-1]; returnString += &quot;}&quot;; return returnString; } //Equals 重写 @Override public boolean equals(Object other){ if(other == this){ return true; } if(other == null){ return false; } if(other.getClass() != this.getClass()){ return false; } ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;) other; if(o.size() == this.size()){ return false; } for(T item: this){ if(!o.contains(item)){ return false; } } return true; } public static void main(String[] args) { ArraySet&lt;Integer&gt; a = new ArraySet&lt;Integer&gt;(); a.add(5); a.add(10); a.add(15); Iterator&lt;Integer&gt; iterator = a.iterator(); while(iterator.hasNext()){ int i = iterator.next(); System.out.println(i); } for(int i : a){ System.out.println(i); } }}","link":"/Reinventing-the-wheel/2020/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88-set/"},{"title":"四则运算表达式","text":"表达式可以分为三种 前缀表达式 中缀表达式 后缀表达式 + 1 2 1+2 1 2 + + 2 * 3 4 2 + 3 * 4 2 3 4 * + + 9 * - 4 1 2 9 + (4 - 1) * 2 9 4 1 - 2 * + 前缀表达式(prefix expression)栈(stack)求值：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。例如前缀表达式“- × + 3 4 5 6”：(1) 从右至左扫描，将6、5、4、3压入堆栈；(2) 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；(3) 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；(4) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。可以看出，用计算机计算前缀表达式的值是很容易的。 中缀表达式(infix expression)将中缀表达式转换为前缀表达式：遵循以下步骤：(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；(2) 从右至左扫描中缀表达式；(3) 遇到操作数时，将其压入S2；(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：(4-1) 如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；(4-2) 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；(4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；(5) 遇到括号时：(5-1) 如果是右括号“)”，则直接压入S1；(5-2) 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；(6) 重复步骤(2)至(5)，直到表达式的最左边；(7) 将S1中剩余的运算符依次弹出并压入S2；(8) 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。 后缀表达式(postfix expression)与前缀表达式类似，只是顺序是从左至右：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。例如后缀表达式“3 4 + 5 × 6 -”：(1) 从左至右扫描，将3和4压入堆栈；(2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；(3) 将5入栈；(4) 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；(5) 将6入栈；(6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。","link":"/Reinventing-the-wheel/2020/05/16/%E7%AE%97%E6%B3%95/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"常见误区","text":"常见误区 线程越多是否效率越高？否！线程切换时需要将线程数据保存读取，会消耗大量资源。","link":"/Reinventing-the-wheel/2020/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/"},{"title":"列表 ArrayList","text":"概述重构思路 size 表示表中数据数 last数据位置为size-1 删除last时，返回last，只改动size 如果size等于容量，扩容并使用arraycopy 以下为generic构造 造轮子 123456789101112131415161718192021222324252627282930313233343536373839404142public class AList&lt;Item&gt; { private Item[] items; private int size; public AList(){ //cannot creat generic array objects,so we use object class and cast items = (Item[]) new Object[100]; size = 0; } public void resize(int capacity){ Item[] a = (Item[]) new Object[capacity]; System.arraycopy(items,0,a,0,size); items = a; } public void addLast(Item x){ if(size == items.length){ resize(size+1); } items[size] = x; size+=1; } public Item getLast(){ return items[size-1]; } public Item get(int i){ return items[i]; } public int getSize(){ return size; } public Item removeLast(){ Item x = getLast(); size-=1; return x; }}","link":"/Reinventing-the-wheel/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%97%E8%A1%A8-ArrayList/"},{"title":"链表 Linked List","text":"概述理论上长度可以无限拓展 以节点的方式储存 每个节点包含data，next：指向下一个节点 各个节点不一定是在连续的储存位置 特性读取数据时需要遍历，而数组可以直接读取 不简洁的list优化改list的大小可以通过迭代和递归得到。如果有一个变量记录大小则可以省略不必要的计算。接下来的链表都会以此优化 造轮子 123456789101112131415161718192021222324252627282930public class IntList { public int first; public IntList rest; public IntList(int first,IntList rest){ this.first = first; this.rest = rest; } // return size of the list using recursion public int size(){ if(rest == null){ return 1; } return 1 + this.rest.size(); } //return size of the list no recursion public int iterativeSize(){ IntList p = this; int count = 0; while(p!= null){ count ++; p = p.rest; } return count; }} 单向链表思路 内部节点,addFront,addEnd，getFirst 内置head变量，避免空指针 内置size变量，避免不必要的计算 缺点 末尾删除数据需要遍历一遍，如果用一个指针指向末尾，删除后还需要指向前一位，还是得遍历一遍 双向链表解决了这个问题 为什么要用static node？这个node不会用到任何实列或者函数，可以用static节省内存使用 造轮子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SLList { //节点 public static class IntNode { public int item; public IntNode next; public IntNode(int item, IntNode next) { this.item = item; this.next = next; } } private IntNode head; private int size; public SLList(){ this.head = new IntNode(666,null); size = 0; } //initialize public SLList(int x) { this.head = new IntNode(666,null); this.head.next = new IntNode(x,null); size = 1; } //add to the front of the list public void addFirst(int x){ head.next = new IntNode(x, head.next); size+=1; } //add element to the end public void addLast(int x){ IntNode p = head;//相当于指针 while(p.next != null){ p = p.next; } p.next = new IntNode(x,null); size+=1; } public int size(){ return size; } //returns first item int the list public int getHead(){ return head.next.item; }} 双向列表加入head 和 tail指向前和后， 可以快速从尾部插入 ###思路","link":"/Reinventing-the-wheel/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8-Linked-List/"},{"title":"插入排序 Insertion Sort","text":"概述寻找该元素的适当位置并插入特点： 如果input是已排序完的，消耗时间很少，只需要查看当前数字前一位。 如果input为倒序，则耗费大量时间，遍历数组 时间n^2 图解过程 1234567891011121314151617public void sort(int arr[]) { int n = arr.length; for (int i = 1; i &lt; n; ++i) { int key = arr[i]; int j = i - 1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } }","link":"/Reinventing-the-wheel/2020/03/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"选择排序 selection Sort","text":"概述按指定的规则选出来某个元素，再依规定交换位置.可以不断缩小范围将最小值放在前方。 图解过程// Find the minimum element in arr[0…4]// and place it at beginning11 25 12 22 64 // Find the minimum element in arr[1…4]// and place it at beginning of arr[1…4]11 12 25 22 64 // Find the minimum element in arr[2…4]// and place it at beginning of arr[2…4]11 12 22 25 64 // Find the minimum element in arr[3…4]// and place it at beginning of arr[3…4]11 12 22 25 64 造轮子 1234567891011121314151617181920public void sort(int arr[]) { int n = arr.length; // One by one move boundary of unsorted subarray for (int i = 0; i &lt; n-1; i++) { // Find the minimum element in unsorted array int min_idx = i; for (int j = i+1; j &lt; n; j++) if (arr[j] &lt; arr[min_idx]) min_idx = j; // Swap the found minimum element with the first // element int temp = arr[min_idx]; arr[min_idx] = arr[i]; arr[i] = temp; } }","link":"/Reinventing-the-wheel/2020/03/12/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"title":"冒泡排序 Bubble Sort","text":"概述通过对待排序序列从前向后，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部. 图解过程原始数组：3，9，-1，10，20 第一趟排序：// 如果相邻的元素逆序就交换1：3，9，-1，10，20 // 比较 3 和 9，不用交换2：3，9，-1，10，20 // 比较 9 和 -1，交换位置3：3，-1，9，10，20 // 比较 9 和 10，不用交换4：3，-1，9，10，20 // 比较 10 和 20，不用交换；而且确定了最大值 20 第二趟排序：// 因为 20 是最大值，其实只需要比较前面 4 个就行了1：-1，3，9，10，20 // 比较 3 和 -1，进行交换2：-1，3，9，10，20 // 比较 3 和 9，不用交换3：-1，3，9，10，20 // 比较 9 和 10，不用交换；确定了本轮最大值 10 第三趟排序：// 因为 10 是上一轮最大值，只需要比较前 3 个1：-1，3，9，10，20 // 比较 -1 和 3，不用交换2：-1，3，9，10，20 // 比较 3 和 9 ，不用交换；确定了本轮最大值 9 第四趟排序：// 上一轮最大值为 9，只需要比较前 2 个1：-1，3，9，10，20 // 比较 -1 和 3，不需要交换，bending本轮最大值 3 造轮子 12345678910111213public void bubbleSort(int arr[]) { int n = arr.length; for (int i = 0; i &lt; n-1; i++) for (int j = 0; j &lt; n-i-1; j++) if (arr[j] &gt; arr[j+1]) { // swap arr[j+1] and arr[j] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } }","link":"/Reinventing-the-wheel/2020/03/07/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"队列 Queue","text":"概述 队列(Queue)是一个先进先出(FIFO：First In First Out)的有序表，可以由数组或者链表实现。由链表实现的队列和List的区别在于，List可以在任意位置添加和删除元素，而队列只有两个操作：1.把元素添加到队列末尾；2.从队列头部取出元素。 数组队列和普通数组的区别在于，array可以在任意位置添加和删除元素，而队列只有两个操作：1.把元素添加到队列末尾；2.从队列头部取出元素。 思路 初始化:front,rear,max size isFull: rear == maxSize -1，isEmpty: rear == front addQueue：rear 后移,getQueue：front后移 viewQueue，headQueue: 查看头部 缺点该数组只能用一次，取出数据后空间不可用。可以改进成环形数组。 造轮子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ArrayQueue { private int maxSize;//数组最大容量 private int front;//队列头部 private int rear;//队列尾部 private int[] arr;//存放数据模拟队列 //初始化 public ArrayQueue(int maxSize){ this.maxSize = maxSize; arr = new int[maxSize]; front = -1;//队列头部前一个位置 rear = -1;//队列尾部 } //判断队列是否满 public boolean isFull(){ return rear == maxSize - 1; } //判断队列是否为空 public boolean isEmpty(){ return rear == front; } //添加值 public void addQueue(int n){ if(isFull()){ System.out.println(&quot;no available space in queue &quot;); return; } rear++; arr[rear] = n; } //取值 public int getQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;queue empty&quot;); } front++; return arr[front]; } //显示队列 public void viewQueue(){ if(isEmpty()){ System.out.println(&quot;empty queue&quot;); return; } for(int x : arr){ System.out.println(x); } } //查看头部 public int headQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;empty queue&quot;); } return arr[front + 1]; }} 环形数组队列实际上并没有实际的环形，对代码进行处理便可以实现虚拟环形。 思路 front 指向队列第一个元素，初始值为0。 rear 指向队列最后一个元素的后一个位置，预留一个位置作判断，初始值为0。 (rear + 1)%maxSize == front ，队列为满.利用remainder查看虚拟环形下一个位置。 remainder 实际作用是让指针在规定区间移动，达到虚拟环绕效果4. rear = front ,队列为空5. 有效数据个数，(rear-front+maxSize)%maxSize 造轮子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CircleArrayQueue { private int maxSize;//数组最大容量 private int front;//队列头部 private int rear;//队列尾部 private int[] arr;//存放数据模拟队列 //初始化 public CircleArrayQueue(int maxSize){ this.maxSize = maxSize; arr = new int[maxSize]; } //判断队列是否满 public boolean isFull(){ return (rear + 1)%maxSize == front; } //判断队列是否为空 public boolean isEmpty(){ return rear == front; } //添加值 public void addQueue(int n){ if(isFull()){ System.out.println(&quot;no available space in queue &quot;); return; } arr[rear] = n; //remainder,超出范围往前跳 rear = (rear + 1) % maxSize; } //取值 public int getQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;queue empty&quot;); } int temp = arr[front]; front = (front + 1)%maxSize; return temp; } //显示队列 public void viewQueue(){ if(isEmpty()){ System.out.println(&quot;empty queue&quot;); return; } for(int i = front;i&lt;front+size();i++){ System.out.println(&quot;arr[&quot;+i%maxSize+&quot;]= &quot;+arr[i%maxSize] ); } } public int size(){ return (rear - front +maxSize)%maxSize; } //查看头部 public int headQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;empty queue&quot;); } return arr[front]; } 链表队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// A linked list (LL) node to store a queue entry class QNode { int key; QNode next; // constructor to create a new linked list node public QNode(int key) { this.key = key; this.next = null; } } // A class to represent a queue // The queue, front stores the front node of LL and rear stores the // last node of LL class Queue { QNode front, rear; public Queue() { this.front = this.rear = null; } // Method to add an key to the queue. void enqueue(int key) { // Create a new LL node QNode temp = new QNode(key); // If queue is empty, then new node is front and rear both if (this.rear == null) { this.front = this.rear = temp; return; } // Add the new node at the end of queue and change rear this.rear.next = temp; this.rear = temp; } // Method to remove an key from queue. void dequeue() { // If queue is empty, return NULL. if (this.front == null) return; // Store previous front and move front one node ahead QNode temp = this.front; this.front = this.front.next; // If front becomes NULL, then change rear also as NULL if (this.front == null) this.rear = null; } }","link":"/Reinventing-the-wheel/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"},{"title":"稀疏数组 sparse array","text":"概述在一个数组里有多个同值的单元时，可以用稀疏数组进行压缩，只保留有效数字。也就是说在数据稀少的情况下才有优势。 举个栗子下图二维数组里，大多数都是0，真正有意义的数字只有5个。存那么多零岂不是浪费空间？ 因此我们可以根据对应的行列，只存储有效数值。注意:第一部分存储总行列数和有效值个数，以便于复原时创建数组。 二维转稀数思路1.遍历二维数组，得到有效值数量sum2.根据sum创建稀数组，spareArr int[sum+1][列]3.将有效数值存入稀数组 稀数转二维思路1.读取第一行数据后创建二维数组2.继续读取数据，存入二维数组 造轮子！！我们可以来看一下稀数数组在五子棋的应用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//五子棋游戏//创建11*11的二维数组//0：无棋子 1：黑子 2：蓝子int chessArr1[][] = new int[11][11];chessArr1[1][2] = 1;chessArr1[2][3] = 2;//输出棋盘System.out.println(&quot;棋盘&quot;);for(int[] row : chessArr1){ for(int data : row){ System.out.printf(&quot;%d\\t&quot;,data); } System.out.println();}//遍历数组得到有效值个数int sum = 0;for(int i = 0;i &lt; 11;i++){ for(int j = 0;j &lt; 11;j++){ if(chessArr1[i][j] != 0){ sum++; } }}//创建稀数数组int sparseArr[][] = new int[sum+1][3];sparseArr[0][0] = 11;sparseArr[0][1] = 11;sparseArr[0][2] = sum;//存入数据int count = 0;for(int i = 0;i &lt; 11;i++){ for(int j = 0;j &lt; 11;j++){ if(chessArr1[i][j] != 0){ count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } }}System.out.println(&quot;稀疏数组&quot;);for(int i = 0;i&lt;sparseArr.length;i++){ System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);}//恢复int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];for(int i =1;i&lt;sparseArr.length;i++){ chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];}//打印出来System.out.println(&quot;棋盘&quot;);for(int[] row : chessArr1){ for(int data : row){ System.out.printf(&quot;%d\\t&quot;,data); } System.out.println();} 最后输出的效果图是这样的","link":"/Reinventing-the-wheel/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"title":"数据结构 简介","text":"简介数据结构是存储、组织数据的方式。它包含三方面的内容，逻辑关系、存储关系及操作。可分为线性结构和非线性结构。 线性结构数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。 [稀疏数组] 存储结构顺序存储结构：一组地址连续的存储单元依次存储线性表的各个数据元素链式存储结构：一组任意的存储单元来存储线性表的数据元素，这些单元可以分散在内存中的任意位置 非线性结构各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图","link":"/Reinventing-the-wheel/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%80%E4%BB%8B/"},{"title":"跳转查找 Jump search","text":"图解 使用已排序数组是这个算法的先前条件。从左边开始每次跳过一定的长度，如果发现搜寻的数字在上一个跳过的数据里再往回用线性搜索。 造轮子！！123456789101112131415161718192021222324252627282930313233343536public int jumpSearch(int[] arr, int x) { int n = arr.length; // Finding block size to be jumped int step = (int)Math.floor(Math.sqrt(n)); // Finding the block where element is // present (if it is present) int prev = 0; while (arr[Math.min(step, n)-1] &lt; x) { prev = step; step += (int)Math.floor(Math.sqrt(n)); if (prev &gt;= n) return -1; } // Doing a linear search for x in block // beginning with prev. while (arr[prev] &lt; x) { prev++; // If we reached next block or end of // array, element is not present. if (prev == Math.min(step, n)) return -1; } // If element is found if (arr[prev] == x) return prev; return -1; } 复杂度分析123456789101112时间： 假设每次跳跃m 最坏情况：跳n/m次，然后再往回查询m-1 k = n/m + m - 1 最差复杂性： O(sqrt(n))空间： 复杂性： O(1) 未完类似方法 指数搜索 (Exponential Search)其它Fibonacci SearchThe Ubiquitous Binary Search","link":"/Reinventing-the-wheel/2020/02/12/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E8%B7%B3%E8%BD%AC%E6%9F%A5%E6%89%BE/"},{"title":"二分查找 Binary search","text":"图解 使用已排序数组是这个算法的先前条件，该方法每次将数据对半分进行查询。 迭代法 Iterative来造轮子！！ 12345678910111213141516public int binarySearch(int array[], int target){ int left = 0; int right = array.length-1; while(left &lt;= right){ int mid = left + (right - left) / 2; if(array[mid] == target){ return mid; }else if(target &lt; array[mid]){ right = mid -1; }else { left = mid + 1; } } return -1; } 思路定义head，tail，mid，根据mid大小移动head 和 tail。 sudo code1234567两个变量记录头和尾while 头 &lt;= 尾 定义 mid ： 1. mid = target , return mid 2. mid &gt;target , 尾左移 3. Mid &lt; target，头右移数组查找完毕，return -1 复杂度分析12345678910111213时间： n/2,n/4,n/6…. ---&gt; n/2^k 最坏情况：n/2^k = 1 2^k = n K = log n 最差复杂性： O(log n) 平均复杂性： O(log n)空间： 复杂性： O(1) 递归法 Recursive来造轮子！！ 123456789101112131415161718192021222324public int binarySearch(int arr[], int l, int r, int x) { if (r &gt;= l) { int mid = l + (r - l) / 2; // If the element is present at the // middle itself if (arr[mid] == x) return mid; // If element is smaller than mid, then // it can only be present in left subarray if (arr[mid] &gt; x) return binarySearch(arr, l, mid - 1, x); // Else the element can only be present // in right subarray return binarySearch(arr, mid + 1, r, x); } // We reach here when element is not present // in array return -1; } 未完类似方法 插值搜索 (Interpolation search)","link":"/Reinventing-the-wheel/2020/02/08/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"KMP算法","text":"简介 kmp算法也称为字符串查找算法，可以确认当前字符串中是否包含目标字符串。 当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 暴力解法在深入了解KMP之前我们需要了解暴力解法。话不多说先上图！ 首先我们从T[0]开始和P比较，直到T[3] 和 P[3] 不匹配。然后从T[1]开始重新和P比较。 这时T[1] 不匹配 P[1]，从T[2]开始重新和P比较. 以此类推直到找到第一组存在的目标。这时如果T数组还有多余长度可以继续往下搜寻。但当前T数组已经比较完，此时结束查找。 暴力的负面效果在某些情况下暴力解法效率极低，我们再来看一个列子。 在这种情况下每次不匹配只会发生在P[4], 也就是说每次第5位出错前我们会经历很多次的无意义比较。这样会导致效率低下，而kmp很好得解决了这个问题。 前缀表(prefix table)首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 部分匹配值 就是”前缀”和”后缀”的最长的共有元素的长度。 前缀表实际应用直接跳过了重复的部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void KMPSearch(String pat, String txt) { int M = pat.length(); int N = txt.length(); // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[] // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] while (i &lt; N) { if (pat.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println(&quot;Found pattern &quot; + &quot;at index &quot; + (i - j)); j = lps[j - 1]; } // mismatch after j matches else if (i &lt; N &amp;&amp; pat.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } } public void computeLPSArray(String pat, int M, int lps[]) { // length of the previous longest prefix suffix int len = 0; int i = 1; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 while (i &lt; M) { if (pat.charAt(i) == pat.charAt(len)) { len++; lps[i] = len; i++; } else // (pat[i] != pat[len]) { // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) { len = lps[len - 1]; // Also, note that we do not increment // i here } else // if (len == 0) { lps[i] = len; i++; } } } } 复杂度分析平均复杂性： O(log n)未完","link":"/Reinventing-the-wheel/2020/02/06/%E7%AE%97%E6%B3%95/%E9%AB%98%E9%98%B6/KMP/"},{"title":"线性查找 Linear search","text":"图解 这种方法太过于暴力，从左到右依次查询，相比于其他算法性能较差。 但优点在于可以对无序数组直接进行查询（你先排序再用二分不是更香？）。不过基本上也不会怎么用到啦~~~ 迭代法 Iterative来造轮子！！ 12345678910public int search(int arr[], int x) { int n = arr.length; for (int i = 0; i &lt; n; i++) { if (arr[i] == x) return i; } return -1; } 复杂度分析最差复杂性： O(n)平均复杂性： O(n)空间复杂性： O(1)","link":"/Reinventing-the-wheel/2020/02/01/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"简介","slug":"简介","link":"/Reinventing-the-wheel/tags/%E7%AE%80%E4%BB%8B/"},{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/tags/JVM/"},{"name":"书籍阅读","slug":"书籍阅读","link":"/Reinventing-the-wheel/tags/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/Reinventing-the-wheel/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","link":"/Reinventing-the-wheel/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"设计模式","slug":"设计模式","link":"/Reinventing-the-wheel/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"linux","slug":"linux","link":"/Reinventing-the-wheel/tags/linux/"},{"name":"Java","slug":"Java","link":"/Reinventing-the-wheel/tags/Java/"}],"categories":[{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/categories/JVM/"},{"name":"JVM 简介","slug":"JVM/JVM-简介","link":"/Reinventing-the-wheel/categories/JVM/JVM-%E7%AE%80%E4%BB%8B/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"算法/查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"},{"name":"数据结构","slug":"数据结构","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"①简介","slug":"数据结构/①简介","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E2%91%A0%E7%AE%80%E4%BB%8B/"},{"name":"排序","slug":"算法/排序","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"线性结构","slug":"数据结构/线性结构","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","link":"/Reinventing-the-wheel/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"非线性结构","slug":"数据结构/非线性结构","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"},{"name":"疑难点","slug":"操作系统/疑难点","link":"/Reinventing-the-wheel/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%96%91%E9%9A%BE%E7%82%B9/"},{"name":"低阶","slug":"算法/低阶","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E4%BD%8E%E9%98%B6/"},{"name":"高阶","slug":"算法/高阶","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E9%AB%98%E9%98%B6/"},{"name":"设计模式","slug":"设计模式","link":"/Reinventing-the-wheel/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"linux","slug":"linux","link":"/Reinventing-the-wheel/categories/linux/"},{"name":"JVM目录","slug":"JVM/JVM目录","link":"/Reinventing-the-wheel/categories/JVM/JVM%E7%9B%AE%E5%BD%95/"},{"name":"Java","slug":"Java","link":"/Reinventing-the-wheel/categories/Java/"}]}