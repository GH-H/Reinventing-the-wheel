{"pages":[],"posts":[{"title":"博客简介","text":"什么是造轮子？「造轮子（Reinventing the wheel）」—— 圆形是大家公认的最合适的车轮形状，而有人非要重新再发明一次轮子不但没有意义、浪费时间，还会使其无法投入更有意义及价值的目标。明知道成功的可能微乎其微，而执意去执行的行为就叫造轮子。 为什么要宣扬造轮子精神？殊不知，造轮子是一种学习方式，能快速通过实践提高自身能力。很多事情看起来简单，但只有自己动手，才会发现其中的难点。想要精通计算机，实践必不可免，没有什么人一出身就站在知识的巅峰。而我希望能宣扬这样一个精神 “明知道你做的不可能比前辈做得更好，却仍然坚持要做。” 简而言之不敲代码你会个锤子？","link":"/Reinventing-the-wheel/2020/02/02/main/"},{"title":"JVM 虚拟机","text":"此文章为个人简易备忘录，请参考原著《深入了解java虚拟机》 JVM 简介Java 虚拟机为所有物理机建立了一个统一的运行平台。在任何虚拟机上编译的程序能在任何虚拟机运行，虚拟层面隐藏了底层技术复杂性和操作系统差异性。 优点相比于C/C++,Java 开发主要集中在业务逻辑上而硬件兼容性。因此应用开发更加高效和快捷。 缺点为了给所有硬件提供一致的虚拟平台，Java硬件效能相对得减少。以至于大多数形况下提升硬件性能无法获得同比的性能回报。 为什么需要学习？–深入了解虚拟机的运作原理可以帮助程序员写出具有高度适应性的代码–帮助排查内存错误–自动运作特性可以帮助java程序员成长–对于企业级开发至关重要 内存区域概述对于C/C++开发人员而言，他们拥有对每一个对象的所有权并且要维护一整个生命周期。所以内存泄漏和内存溢出必须时刻关注。 对于JAVA开发人员而言，内存管理机制操作对象生命周期，不容易出现内存泄漏和溢出问题。一旦出现问题排查难度较高。 运行时数据区域JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。 PC寄存器\\未完 注：《深入了解java虚拟机》至 25 页，61 至","link":"/Reinventing-the-wheel/2021/03/04/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"跳转查找 Jump search","text":"图解 使用已排序数组是这个算法的先前条件。从左边开始每次跳过一定的长度，如果发现搜寻的数字在上一个跳过的数据里再往回用线性搜索。 123456789101112131415161718192021222324252627282930313233343536public int jumpSearch(int[] arr, int x) { int n = arr.length; // Finding block size to be jumped int step = (int)Math.floor(Math.sqrt(n)); // Finding the block where element is // present (if it is present) int prev = 0; while (arr[Math.min(step, n)-1] &lt; x) { prev = step; step += (int)Math.floor(Math.sqrt(n)); if (prev &gt;= n) return -1; } // Doing a linear search for x in block // beginning with prev. while (arr[prev] &lt; x) { prev++; // If we reached next block or end of // array, element is not present. if (prev == Math.min(step, n)) return -1; } // If element is found if (arr[prev] == x) return prev; return -1; } 复杂度分析123456789101112时间： 假设每次跳跃m 最坏情况：跳n/m次，然后再往回查询m-1 k = n/m + m - 1 最差复杂性： O(sqrt(n))空间： 复杂性： O(1) 未完类似方法 指数搜索 (Exponential Search)","link":"/Reinventing-the-wheel/2020/02/10/%E8%B7%B3%E8%BD%AC%E6%9F%A5%E6%89%BE/"},{"title":"二分查找 Binary search","text":"图解 使用已排序数组是这个算法的先前条件，该方法每次将数据对半分进行查询。 迭代法 Iterative12345678910111213141516public int binarySearch(int array[], int target){ int left = 0; int right = array.length-1; while(left &lt;= right){ int mid = left + (right - left) / 2; if(array[mid] == target){ return mid; }else if(target &lt; array[mid]){ right = mid -1; }else { left = mid + 1; } } return -1; } 思路定义head，tail，mid，根据mid大小移动head 和 tail。 sudo code1234567两个变量记录头和尾while 头 &lt;= 尾 定义 mid ： 1. mid = target , return mid 2. mid &gt;target , 尾左移 3. Mid &lt; target，头右移数组查找完毕，return -1 复杂度分析12345678910111213时间： n/2,n/4,n/6…. ---&gt; n/2^k 最坏情况：n/2^k = 1 2^k = n K = log n 最差复杂性： O(log n) 平均复杂性： O(log n)空间： 复杂性： O(1) 递归法 Recursive123456789101112131415161718192021222324public int binarySearch(int arr[], int l, int r, int x) { if (r &gt;= l) { int mid = l + (r - l) / 2; // If the element is present at the // middle itself if (arr[mid] == x) return mid; // If element is smaller than mid, then // it can only be present in left subarray if (arr[mid] &gt; x) return binarySearch(arr, l, mid - 1, x); // Else the element can only be present // in right subarray return binarySearch(arr, mid + 1, r, x); } // We reach here when element is not present // in array return -1; } 未完类似方法 插值搜索 (Interpolation search)","link":"/Reinventing-the-wheel/2020/02/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"},{"title":"KMP算法","text":"简介 kmp算法也称为字符串查找算法，可以确认当前字符串中是否包含目标字符串。 我们可以利用目标字符串自身包含的信息，避免不必要的操作。 暴力解法在深入了解KMP之前我们需要了解暴力解法。话不多说先上图！ 首先我们从T[0]开始和P比较，直到T[3] 和 P[3] 不匹配。然后从T[1]开始重新和P比较。 这时T[1] 不匹配 P[1]，从T[2]开始重新和P比较. 以此类推直到找到第一组存在的目标。这时如果T数组还有多余长度可以继续往下搜寻。但当前T数组已经比较完，此时结束查找。 暴力的负面效果在某些情况下暴力解法效率极低，我们再来看一个列子。 在这种情况下每次不匹配只会发生在P[4], 也就是说每次第5位出错前我们会经历很多次的无意义比较。这样会导致效率低下，而kmp很好得解决了这个问题。","link":"/Reinventing-the-wheel/2020/02/06/KMP/"},{"title":"线性查找 Linear search","text":"图解 这种方法太过于暴力，从左到右依次查询，相比于其他算法性能较差。 但优点在于可以对无序数组直接进行查询（你先排序再用二分不是更香？）。不过基本上也不会怎么用到啦~~~ 迭代法 Iterative12345678910public int search(int arr[], int x) { int n = arr.length; for (int i = 0; i &lt; n; i++) { if (arr[i] == x) return i; } return -1; } 复杂度分析空间复杂性： O(1)最差复杂性： O(n)平均复杂性： O(n)","link":"/Reinventing-the-wheel/2020/02/01/%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"简介","slug":"简介","link":"/Reinventing-the-wheel/tags/%E7%AE%80%E4%BB%8B/"},{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/tags/JVM/"},{"name":"书籍阅读","slug":"书籍阅读","link":"/Reinventing-the-wheel/tags/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/categories/JVM/"},{"name":"JVM 简介","slug":"JVM/JVM-简介","link":"/Reinventing-the-wheel/categories/JVM/JVM-%E7%AE%80%E4%BB%8B/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"算法/查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"},{"name":"②二分查找","slug":"算法/查找/②二分查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E2%91%A1%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"①线性查找","slug":"算法/查找/①线性查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E2%91%A0%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/"},{"name":"③跳转查找","slug":"算法/查找/③跳转查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E2%91%A2%E8%B7%B3%E8%BD%AC%E6%9F%A5%E6%89%BE/"},{"name":"KMP","slug":"算法/KMP","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/KMP/"}]}