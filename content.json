{"pages":[{"title":"JVM 虚拟机","text":"此文章为个人简易备忘录，请参考原著《深入了解java虚拟机》 JVM 简介Java 虚拟机为所有物理机建立了一个统一的运行平台。在任何虚拟机上编译的程序能在任何虚拟机运行，虚拟层面隐藏了底层技术复杂性和操作系统差异性。 优点相比于C/C++,Java 开发主要集中在业务逻辑上而硬件兼容性。因此应用开发更加高效和快捷。 缺点为了给所有硬件提供一致的虚拟平台，Java硬件效能相对得减少。以至于大多数形况下提升硬件性能无法获得同比的性能回报。 为什么需要学习？–深入了解虚拟机的运作原理可以帮助程序员写出具有高度适应性的代码–帮助排查内存错误–自动运作特性可以帮助java程序员成长–对于企业级开发至关重要 内存区域概述对于C/C++开发人员而言，他们拥有对每一个对象的所有权并且要维护一整个生命周期。所以内存泄漏和内存溢出必须时刻关注。 对于JAVA开发人员而言，内存管理机制操作对象生命周期，不容易出现内存泄漏和溢出问题。一旦出现问题排查难度较高。 运行时数据区域JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。 PC寄存器\\未完 注：《深入了解java虚拟机》至 25 页，61 至","link":"/Reinventing-the-wheel/test/index.html"}],"posts":[{"title":"博客简介","text":"博主目前就读于华大(University Of Washing)的菜鸟本科生一枚。只会造个小轮子，偶尔闲着无聊把笔记搬到博客上，顺便理一下知识点。各位大佬有空可去我github瞄一眼，链接右上角。 什么是造轮子？「造轮子（Reinventing the wheel）」—— 圆形是大家公认的最合适的车轮形状，而有人非要重新再发明一次轮子不但没有意义、浪费时间，还会使其无法投入更有意义及价值的目标。明知道成功的可能微乎其微，而执意去执行的行为就叫造轮子。 为什么要宣扬造轮子精神？殊不知，造轮子是一种学习方式，能快速通过实践提高自身能力。很多事情看起来简单，但只有自己动手，才会发现其中的难点。想要精通计算机，实践必不可免，没有什么人一出身就站在知识的巅峰。而我希望能宣扬这样一个精神 “明知道你做的不可能比前辈做得更好，却仍然坚持要做。” 简而言之不敲代码造轮子我还会个锤子？","link":"/Reinventing-the-wheel/2020/02/02/main/"},{"title":"JVM 虚拟机","text":"此文章为个人简易备忘录，请参考原著《深入了解java虚拟机》 JVM 简介Java 虚拟机为所有物理机建立了一个统一的运行平台。在任何虚拟机上编译的程序能在任何虚拟机运行，虚拟层面隐藏了底层技术复杂性和操作系统差异性。 优点相比于C/C++,Java 开发主要集中在业务逻辑上而硬件兼容性。因此应用开发更加高效和快捷。 缺点为了给所有硬件提供一致的虚拟平台，Java硬件效能相对得减少。以至于大多数形况下提升硬件性能无法获得同比的性能回报。 为什么需要学习？–深入了解虚拟机的运作原理可以帮助程序员写出具有高度适应性的代码–帮助排查内存错误–自动运作特性可以帮助java程序员成长–对于企业级开发至关重要 内存区域概述对于C/C++开发人员而言，他们拥有对每一个对象的所有权并且要维护一整个生命周期。所以内存泄漏和内存溢出必须时刻关注。 对于JAVA开发人员而言，内存管理机制操作对象生命周期，不容易出现内存泄漏和溢出问题。一旦出现问题排查难度较高。 运行时数据区域JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。 PC寄存器\\未完 注：《深入了解java虚拟机》至 25 页，61 至","link":"/Reinventing-the-wheel/2021/03/04/JVM/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"插入排序 Insertion Sort","text":"概述寻找该元素的适当位置并插入 图解过程 1234567891011121314151617public void sort(int arr[]) { int n = arr.length; for (int i = 1; i &lt; n; ++i) { int key = arr[i]; int j = i - 1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } }","link":"/Reinventing-the-wheel/2020/03/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"选择排序 selection Sort","text":"概述按指定的规则选出来某个元素，再依规定交换位置.可以不断缩小范围将最小值放在前方。 图解过程// Find the minimum element in arr[0…4]// and place it at beginning11 25 12 22 64 // Find the minimum element in arr[1…4]// and place it at beginning of arr[1…4]11 12 25 22 64 // Find the minimum element in arr[2…4]// and place it at beginning of arr[2…4]11 12 22 25 64 // Find the minimum element in arr[3…4]// and place it at beginning of arr[3…4]11 12 22 25 64 造轮子 1234567891011121314151617181920public void sort(int arr[]) { int n = arr.length; // One by one move boundary of unsorted subarray for (int i = 0; i &lt; n-1; i++) { // Find the minimum element in unsorted array int min_idx = i; for (int j = i+1; j &lt; n; j++) if (arr[j] &lt; arr[min_idx]) min_idx = j; // Swap the found minimum element with the first // element int temp = arr[min_idx]; arr[min_idx] = arr[i]; arr[i] = temp; } }","link":"/Reinventing-the-wheel/2020/03/12/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"title":"冒泡排序 Bubble Sort","text":"概述通过对待排序序列从前向后，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部. 图解过程原始数组：3，9，-1，10，20 第一趟排序：// 如果相邻的元素逆序就交换1：3，9，-1，10，20 // 比较 3 和 9，不用交换2：3，9，-1，10，20 // 比较 9 和 -1，交换位置3：3，-1，9，10，20 // 比较 9 和 10，不用交换4：3，-1，9，10，20 // 比较 10 和 20，不用交换；而且确定了最大值 20 第二趟排序：// 因为 20 是最大值，其实只需要比较前面 4 个就行了1：-1，3，9，10，20 // 比较 3 和 -1，进行交换2：-1，3，9，10，20 // 比较 3 和 9，不用交换3：-1，3，9，10，20 // 比较 9 和 10，不用交换；确定了本轮最大值 10 第三趟排序：// 因为 10 是上一轮最大值，只需要比较前 3 个1：-1，3，9，10，20 // 比较 -1 和 3，不用交换2：-1，3，9，10，20 // 比较 3 和 9 ，不用交换；确定了本轮最大值 9 第四趟排序：// 上一轮最大值为 9，只需要比较前 2 个1：-1，3，9，10，20 // 比较 -1 和 3，不需要交换，bending本轮最大值 3 造轮子 12345678910111213public void bubbleSort(int arr[]) { int n = arr.length; for (int i = 0; i &lt; n-1; i++) for (int j = 0; j &lt; n-i-1; j++) if (arr[j] &gt; arr[j+1]) { // swap arr[j+1] and arr[j] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } }","link":"/Reinventing-the-wheel/2020/03/07/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"队列 Queue","text":"概述 队列(Queue)是一个先进先出(FIFO：First In First Out)的有序表，可以由数组或者链表实现。由链表实现的队列和List的区别在于，List可以在任意位置添加和删除元素，而队列只有两个操作：1.把元素添加到队列末尾；2.从队列头部取出元素。 数组队列和普通数组的区别在于，array可以在任意位置添加和删除元素，而队列只有两个操作：1.把元素添加到队列末尾；2.从队列头部取出元素。 思路 front和rear 分别指向头和尾。 数组为空时（即front == rear）,尾部后移 造轮子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Queue { private static int front, rear, capacity; private static int queue[]; Queue(int c) { front = rear = 0; capacity = c; queue = new int[capacity]; } // function to insert an element // at the rear of the queue static void queueEnqueue(int data) { // check queue is full or not if (capacity == rear) { System.out.printf(&quot;\\nQueue is full\\n&quot;); return; } // insert element at the rear else { queue[rear] = data; rear++; } return; } // function to delete an element // from the front of the queue static void queueDequeue() { // if queue is empty if (front == rear) { System.out.printf(&quot;\\nQueue is empty\\n&quot;); return; } // shift all the elements from index 2 till rear // to the right by one else { for (int i = 0; i &lt; rear - 1; i++) { queue[i] = queue[i + 1]; } // store 0 at rear indicating there's no element if (rear &lt; capacity) queue[rear] = 0; // decrement rear rear--; } return; } // print queue elements static void queueDisplay() { int i; if (front == rear) { System.out.printf(&quot;\\nQueue is Empty\\n&quot;); return; } // traverse front to rear and print elements for (i = front; i &lt; rear; i++) { System.out.printf(&quot; %d &lt;-- &quot;, queue[i]); } return; } // print front of queue static void queueFront() { if (front == rear) { System.out.printf(&quot;\\nQueue is Empty\\n&quot;); return; } System.out.printf(&quot;\\nFront Element is: %d&quot;, queue[front]); return; } } 链表队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// A linked list (LL) node to store a queue entry class QNode { int key; QNode next; // constructor to create a new linked list node public QNode(int key) { this.key = key; this.next = null; } } // A class to represent a queue // The queue, front stores the front node of LL and rear stores the // last node of LL class Queue { QNode front, rear; public Queue() { this.front = this.rear = null; } // Method to add an key to the queue. void enqueue(int key) { // Create a new LL node QNode temp = new QNode(key); // If queue is empty, then new node is front and rear both if (this.rear == null) { this.front = this.rear = temp; return; } // Add the new node at the end of queue and change rear this.rear.next = temp; this.rear = temp; } // Method to remove an key from queue. void dequeue() { // If queue is empty, return NULL. if (this.front == null) return; // Store previous front and move front one node ahead QNode temp = this.front; this.front = this.front.next; // If front becomes NULL, then change rear also as NULL if (this.front == null) this.rear = null; } }","link":"/Reinventing-the-wheel/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"},{"title":"稀疏数组 sparse array","text":"概述在一个数组里有多个同值的单元时，可以用稀疏数组进行压缩，只保留有效数字。也就是说在数据稀少的情况下才有优势。 举个栗子下图二维数组里，大多数都是0，真正有意义的数字只有5个。存那么多零岂不是浪费空间？ 因此我们可以根据对应的行列，只存储有效数值。注意:第一部分存储总行列数和有效值个数，以便于复原时创建数组。 二维转稀数思路1.遍历二维数组，得到有效值数量sum2.根据sum创建稀数组，spareArr int[sum+1][列]3.将有效数值存入稀数组 稀数转二维思路1.读取第一行数据后创建二维数组2.继续读取数据，存入二维数组 造轮子！！我们可以来看一下稀数数组在五子棋的应用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//五子棋游戏//创建11*11的二维数组//0：无棋子 1：黑子 2：蓝子int chessArr1[][] = new int[11][11];chessArr1[1][2] = 1;chessArr1[2][3] = 2;//输出棋盘System.out.println(&quot;棋盘&quot;);for(int[] row : chessArr1){ for(int data : row){ System.out.printf(&quot;%d\\t&quot;,data); } System.out.println();}//遍历数组得到有效值个数int sum = 0;for(int i = 0;i &lt; 11;i++){ for(int j = 0;j &lt; 11;j++){ if(chessArr1[i][j] != 0){ sum++; } }}//创建稀数数组int sparseArr[][] = new int[sum+1][3];sparseArr[0][0] = 11;sparseArr[0][1] = 11;sparseArr[0][2] = sum;//存入数据int count = 0;for(int i = 0;i &lt; 11;i++){ for(int j = 0;j &lt; 11;j++){ if(chessArr1[i][j] != 0){ count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } }}System.out.println(&quot;稀疏数组&quot;);for(int i = 0;i&lt;sparseArr.length;i++){ System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);}//恢复int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];for(int i =1;i&lt;sparseArr.length;i++){ chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];}//打印出来System.out.println(&quot;棋盘&quot;);for(int[] row : chessArr1){ for(int data : row){ System.out.printf(&quot;%d\\t&quot;,data); } System.out.println();} 最后输出的效果图是这样的","link":"/Reinventing-the-wheel/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"title":"数据结构 简介","text":"简介数据结构是存储、组织数据的方式。它包含三方面的内容，逻辑关系、存储关系及操作。可分为线性结构和非线性结构。 线性结构数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。 存储结构顺序存储结构：一组地址连续的存储单元依次存储线性表的各个数据元素链式存储结构：一组任意的存储单元来存储线性表的数据元素，这些单元可以分散在内存中的任意位置 非线性结构各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图","link":"/Reinventing-the-wheel/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%80%E4%BB%8B/"},{"title":"跳转查找 Jump search","text":"图解 使用已排序数组是这个算法的先前条件。从左边开始每次跳过一定的长度，如果发现搜寻的数字在上一个跳过的数据里再往回用线性搜索。 造轮子！！123456789101112131415161718192021222324252627282930313233343536public int jumpSearch(int[] arr, int x) { int n = arr.length; // Finding block size to be jumped int step = (int)Math.floor(Math.sqrt(n)); // Finding the block where element is // present (if it is present) int prev = 0; while (arr[Math.min(step, n)-1] &lt; x) { prev = step; step += (int)Math.floor(Math.sqrt(n)); if (prev &gt;= n) return -1; } // Doing a linear search for x in block // beginning with prev. while (arr[prev] &lt; x) { prev++; // If we reached next block or end of // array, element is not present. if (prev == Math.min(step, n)) return -1; } // If element is found if (arr[prev] == x) return prev; return -1; } 复杂度分析123456789101112时间： 假设每次跳跃m 最坏情况：跳n/m次，然后再往回查询m-1 k = n/m + m - 1 最差复杂性： O(sqrt(n))空间： 复杂性： O(1) 未完类似方法 指数搜索 (Exponential Search)其它Fibonacci SearchThe Ubiquitous Binary Search","link":"/Reinventing-the-wheel/2020/02/12/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E8%B7%B3%E8%BD%AC%E6%9F%A5%E6%89%BE/"},{"title":"二分查找 Binary search","text":"图解 使用已排序数组是这个算法的先前条件，该方法每次将数据对半分进行查询。 迭代法 Iterative来造轮子！！ 12345678910111213141516public int binarySearch(int array[], int target){ int left = 0; int right = array.length-1; while(left &lt;= right){ int mid = left + (right - left) / 2; if(array[mid] == target){ return mid; }else if(target &lt; array[mid]){ right = mid -1; }else { left = mid + 1; } } return -1; } 思路定义head，tail，mid，根据mid大小移动head 和 tail。 sudo code1234567两个变量记录头和尾while 头 &lt;= 尾 定义 mid ： 1. mid = target , return mid 2. mid &gt;target , 尾左移 3. Mid &lt; target，头右移数组查找完毕，return -1 复杂度分析12345678910111213时间： n/2,n/4,n/6…. ---&gt; n/2^k 最坏情况：n/2^k = 1 2^k = n K = log n 最差复杂性： O(log n) 平均复杂性： O(log n)空间： 复杂性： O(1) 递归法 Recursive来造轮子！！ 123456789101112131415161718192021222324public int binarySearch(int arr[], int l, int r, int x) { if (r &gt;= l) { int mid = l + (r - l) / 2; // If the element is present at the // middle itself if (arr[mid] == x) return mid; // If element is smaller than mid, then // it can only be present in left subarray if (arr[mid] &gt; x) return binarySearch(arr, l, mid - 1, x); // Else the element can only be present // in right subarray return binarySearch(arr, mid + 1, r, x); } // We reach here when element is not present // in array return -1; } 未完类似方法 插值搜索 (Interpolation search)","link":"/Reinventing-the-wheel/2020/02/08/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"KMP算法","text":"简介 kmp算法也称为字符串查找算法，可以确认当前字符串中是否包含目标字符串。 当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 暴力解法在深入了解KMP之前我们需要了解暴力解法。话不多说先上图！ 首先我们从T[0]开始和P比较，直到T[3] 和 P[3] 不匹配。然后从T[1]开始重新和P比较。 这时T[1] 不匹配 P[1]，从T[2]开始重新和P比较. 以此类推直到找到第一组存在的目标。这时如果T数组还有多余长度可以继续往下搜寻。但当前T数组已经比较完，此时结束查找。 暴力的负面效果在某些情况下暴力解法效率极低，我们再来看一个列子。 在这种情况下每次不匹配只会发生在P[4], 也就是说每次第5位出错前我们会经历很多次的无意义比较。这样会导致效率低下，而kmp很好得解决了这个问题。 前缀表(prefix table)首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 部分匹配值 就是”前缀”和”后缀”的最长的共有元素的长度。 前缀表实际应用直接跳过了重复的部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void KMPSearch(String pat, String txt) { int M = pat.length(); int N = txt.length(); // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[] // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] while (i &lt; N) { if (pat.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println(&quot;Found pattern &quot; + &quot;at index &quot; + (i - j)); j = lps[j - 1]; } // mismatch after j matches else if (i &lt; N &amp;&amp; pat.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } } public void computeLPSArray(String pat, int M, int lps[]) { // length of the previous longest prefix suffix int len = 0; int i = 1; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 while (i &lt; M) { if (pat.charAt(i) == pat.charAt(len)) { len++; lps[i] = len; i++; } else // (pat[i] != pat[len]) { // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) { len = lps[len - 1]; // Also, note that we do not increment // i here } else // if (len == 0) { lps[i] = len; i++; } } } } 复杂度分析平均复杂性： O(log n)未完","link":"/Reinventing-the-wheel/2020/02/06/%E7%AE%97%E6%B3%95/KMP/"},{"title":"线性查找 Linear search","text":"图解 这种方法太过于暴力，从左到右依次查询，相比于其他算法性能较差。 但优点在于可以对无序数组直接进行查询（你先排序再用二分不是更香？）。不过基本上也不会怎么用到啦~~~ 迭代法 Iterative来造轮子！！ 12345678910public int search(int arr[], int x) { int n = arr.length; for (int i = 0; i &lt; n; i++) { if (arr[i] == x) return i; } return -1; } 复杂度分析最差复杂性： O(n)平均复杂性： O(n)空间复杂性： O(1)","link":"/Reinventing-the-wheel/2020/02/01/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"简介","slug":"简介","link":"/Reinventing-the-wheel/tags/%E7%AE%80%E4%BB%8B/"},{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/tags/JVM/"},{"name":"书籍阅读","slug":"书籍阅读","link":"/Reinventing-the-wheel/tags/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/Reinventing-the-wheel/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/categories/JVM/"},{"name":"JVM 简介","slug":"JVM/JVM-简介","link":"/Reinventing-the-wheel/categories/JVM/JVM-%E7%AE%80%E4%BB%8B/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"算法/查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"},{"name":"②二分查找","slug":"算法/查找/②二分查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E2%91%A1%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"①线性查找","slug":"算法/查找/①线性查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E2%91%A0%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE/"},{"name":"③跳转查找","slug":"算法/查找/③跳转查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E2%91%A2%E8%B7%B3%E8%BD%AC%E6%9F%A5%E6%89%BE/"},{"name":"KMP","slug":"算法/KMP","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/KMP/"},{"name":"数据结构","slug":"数据结构","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"①简介","slug":"数据结构/①简介","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E2%91%A0%E7%AE%80%E4%BB%8B/"},{"name":"②稀疏数组","slug":"数据结构/②稀疏数组","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E2%91%A1%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"name":"③队列","slug":"数据结构/③队列","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E2%91%A2%E9%98%9F%E5%88%97/"},{"name":"排序","slug":"算法/排序","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"①冒泡排序","slug":"算法/排序/①冒泡排序","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E2%91%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"③插入排序","slug":"算法/排序/③插入排序","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E2%91%A2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"②选择排序","slug":"算法/排序/②选择排序","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E2%91%A1%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"}]}