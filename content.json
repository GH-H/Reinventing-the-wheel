{"pages":[{"title":"简历","text":"个人信息 姓名：黄港欢 &emsp;&emsp;&emsp;性 别：男&emsp;&emsp;&emsp;&emsp;年 龄：24 技术博客：https://gh-h.github.io/Reinventing-the-wheel/ Github：https://github.com/GH-H?tab=repositories 微信：h820546005 &emsp;&emsp;&emsp;&emsp; 邮 箱：huangganghuan1@gmail.com 教育经历 华盛顿大学 University of Washington &emsp;&emsp;&emsp;&emsp;&ensp;&emsp;&emsp;&ensp;&emsp;&emsp;&ensp;本科 2019.04 - 2021.06 专 业：计算机科学与系统(Computer Science and Systems)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GPA: 3.27 /4.0 下学期课程(3月学季制)：数据库内部系统，计算机系统 专业技能 熟悉 Java 了解 git,数据库(mysql,sql server)，C 数据结构和算法，计算机网络，计算机原理 项目经历 学校–Java 重构 Pep/8 汇编语言虚拟机–4人Scrum团队敏捷开发模式 具体功能 ：实现27/36个指令。虚拟机附带图形用户界面，可解析十六进制和汇编语言,执行代码并显示cpu和内存数据。 技术难点: 1.团队代码不规范，github代码审查困难。2.需要将27个指令模块化后分配开发任务。3.控制反码，补码以及数据的溢出 4.cpu以及内存设计 5.内存指针跳转 6.代码测试100%覆盖率 等等 个人贡献以及收获：参与设计cpu和内存，以接口和多态拆分指令优化解码。对计算机原理和汇编有进一步的了解，进一步熟悉git管理,团队合作代码审核 github链接： https://github.com/GH-H/Pep-8-simulator 个人-英雄联盟数据库设计-独立开发 具体实现：设计关系型ER 数据库模型 并使用sqlserver 和c#实现用户注册 和 数据库增删查改 技术难点: 实际上用 visual studio 做简易UI，连接数据库难度不高，该项目主要侧重于数据库范式设计的应用和增删查改的优化 github链接： https://github.com/GH-H/MOBA-Game-statistic-Information-Database","link":"/Reinventing-the-wheel/%E7%AE%80%E5%8E%86/index.html"}],"posts":[{"title":"博客简介","text":"博主目前就读于华大(University Of Washing)的菜鸟本科生一枚。只会造个小轮子，偶尔闲着无聊把笔记搬到博客上，顺便理一下知识点。各位大佬有空可去我github瞄一眼，链接右上角。 什么是造轮子？「造轮子（Reinventing the wheel）」—— 圆形是大家公认的最合适的车轮形状，而有人非要重新再发明一次轮子不但没有意义、浪费时间，还会使其无法投入更有意义及价值的目标。明知道成功的可能微乎其微，而执意去执行的行为就叫造轮子。 为什么要宣扬造轮子精神？殊不知，造轮子是一种学习方式，能快速通过实践提高自身能力。很多事情看起来简单，但只有自己动手，才会发现其中的难点。想要精通计算机，实践必不可免，没有什么人一出身就站在知识的巅峰。而我希望能宣扬这样一个精神 “明知道你做的不可能比前辈做得更好，却仍然坚持要做。” 简而言之不敲代码造轮子我还会个锤子？","link":"/Reinventing-the-wheel/2020/02/02/main/"},{"title":"JVM 虚拟机","text":"此文章为个人简易备忘录，请参考原著《深入了解java虚拟机》 JVM 简介Java 虚拟机为所有物理机建立了一个统一的运行平台。在任何虚拟机上编译的程序能在任何虚拟机运行，虚拟层面隐藏了底层技术复杂性和操作系统差异性。 优点相比于C/C++,Java 开发主要集中在业务逻辑上而硬件兼容性。因此应用开发更加高效和快捷。 缺点为了给所有硬件提供一致的虚拟平台，Java硬件效能相对得减少。以至于大多数形况下提升硬件性能无法获得同比的性能回报。 为什么需要学习？–深入了解虚拟机的运作原理可以帮助程序员写出具有高度适应性的代码–帮助排查内存错误–自动运作特性可以帮助java程序员成长–对于企业级开发至关重要 内存区域概述对于C/C++开发人员而言，他们拥有对每一个对象的所有权并且要维护一整个生命周期。所以内存泄漏和内存溢出必须时刻关注。 对于JAVA开发人员而言，内存管理机制操作对象生命周期，不容易出现内存泄漏和溢出问题。一旦出现问题排查难度较高。 运行时数据区域JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。 PC寄存器\\未完 注：《深入了解java虚拟机》至 25 页，61 至","link":"/Reinventing-the-wheel/2021/03/04/JVM/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"链表 Linked List","text":"概述 以节点的方式储存 每个节点包含data，next：指向下一个节点 各个节点不一定是在连续的储存位置 不简洁的list优化改list的大小可以通过迭代和递归得到。如果有一个变量记录大小则可以省略不必要的计算。接下来的链表都会以此优化 123456789101112131415161718192021222324252627282930public class IntList { public int first; public IntList rest; public IntList(int first,IntList rest){ this.first = first; this.rest = rest; } // return size of the list using recursion public int size(){ if(rest == null){ return 1; } return 1 + this.rest.size(); } //return size of the list no recursion public int iterativeSize(){ IntList p = this; int count = 0; while(p!= null){ count ++; p = p.rest; } return count; }} 单向链表思路 内部节点,addFront,addEnd，getFirst 内置head变量，避免空指针 内置size变量，避免不必要的计算 缺点 末尾删除数据需要遍历一遍，如果用一个指针指向末尾，删除后还需要指向前一位，还是得遍历一遍 双向链表解决了这个问题 为什么要用static node？这个node不会用到任何实列或者函数，可以用static节省内存使用 造轮子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SLList { //节点 public static class IntNode { public int item; public IntNode next; public IntNode(int item, IntNode next) { this.item = item; this.next = next; } } private IntNode head; private int size; public SLList(){ this.head = new IntNode(666,null); size = 0; } //initialize public SLList(int x) { this.head = new IntNode(666,null); this.head.next = new IntNode(x,null); size = 1; } //add to the front of the list public void addFirst(int x){ head.next = new IntNode(x, head.next); size+=1; } //add element to the end public void addLast(int x){ IntNode p = head;//相当于指针 while(p.next != null){ p = p.next; } p.next = new IntNode(x,null); size+=1; } public int size(){ return size; } //returns first item int the list public int getHead(){ return head.next.item; }} 双向列表###思路 InsertAtHead — 在链表开头插入元素 Delete — 删除链表的指定元素 DeleteAtHead — 删除链表第一个元素 Search — 在链表中查询指定元素 isEmpty — 查询链表是否为空","link":"/Reinventing-the-wheel/2020/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8-Linked-List/"},{"title":"插入排序 Insertion Sort","text":"概述寻找该元素的适当位置并插入 图解过程 1234567891011121314151617public void sort(int arr[]) { int n = arr.length; for (int i = 1; i &lt; n; ++i) { int key = arr[i]; int j = i - 1; /* Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position */ while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } }","link":"/Reinventing-the-wheel/2020/03/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"title":"选择排序 selection Sort","text":"概述按指定的规则选出来某个元素，再依规定交换位置.可以不断缩小范围将最小值放在前方。 图解过程// Find the minimum element in arr[0…4]// and place it at beginning11 25 12 22 64 // Find the minimum element in arr[1…4]// and place it at beginning of arr[1…4]11 12 25 22 64 // Find the minimum element in arr[2…4]// and place it at beginning of arr[2…4]11 12 22 25 64 // Find the minimum element in arr[3…4]// and place it at beginning of arr[3…4]11 12 22 25 64 造轮子 1234567891011121314151617181920public void sort(int arr[]) { int n = arr.length; // One by one move boundary of unsorted subarray for (int i = 0; i &lt; n-1; i++) { // Find the minimum element in unsorted array int min_idx = i; for (int j = i+1; j &lt; n; j++) if (arr[j] &lt; arr[min_idx]) min_idx = j; // Swap the found minimum element with the first // element int temp = arr[min_idx]; arr[min_idx] = arr[i]; arr[i] = temp; } }","link":"/Reinventing-the-wheel/2020/03/12/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"title":"冒泡排序 Bubble Sort","text":"概述通过对待排序序列从前向后，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部. 图解过程原始数组：3，9，-1，10，20 第一趟排序：// 如果相邻的元素逆序就交换1：3，9，-1，10，20 // 比较 3 和 9，不用交换2：3，9，-1，10，20 // 比较 9 和 -1，交换位置3：3，-1，9，10，20 // 比较 9 和 10，不用交换4：3，-1，9，10，20 // 比较 10 和 20，不用交换；而且确定了最大值 20 第二趟排序：// 因为 20 是最大值，其实只需要比较前面 4 个就行了1：-1，3，9，10，20 // 比较 3 和 -1，进行交换2：-1，3，9，10，20 // 比较 3 和 9，不用交换3：-1，3，9，10，20 // 比较 9 和 10，不用交换；确定了本轮最大值 10 第三趟排序：// 因为 10 是上一轮最大值，只需要比较前 3 个1：-1，3，9，10，20 // 比较 -1 和 3，不用交换2：-1，3，9，10，20 // 比较 3 和 9 ，不用交换；确定了本轮最大值 9 第四趟排序：// 上一轮最大值为 9，只需要比较前 2 个1：-1，3，9，10，20 // 比较 -1 和 3，不需要交换，bending本轮最大值 3 造轮子 12345678910111213public void bubbleSort(int arr[]) { int n = arr.length; for (int i = 0; i &lt; n-1; i++) for (int j = 0; j &lt; n-i-1; j++) if (arr[j] &gt; arr[j+1]) { // swap arr[j+1] and arr[j] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } }","link":"/Reinventing-the-wheel/2020/03/07/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"队列 Queue","text":"概述 队列(Queue)是一个先进先出(FIFO：First In First Out)的有序表，可以由数组或者链表实现。由链表实现的队列和List的区别在于，List可以在任意位置添加和删除元素，而队列只有两个操作：1.把元素添加到队列末尾；2.从队列头部取出元素。 数组队列和普通数组的区别在于，array可以在任意位置添加和删除元素，而队列只有两个操作：1.把元素添加到队列末尾；2.从队列头部取出元素。 思路 初始化:front,rear,max size isFull: rear == maxSize -1，isEmpty: rear == front addQueue：rear 后移,getQueue：front后移 viewQueue，headQueue: 查看头部 缺点该数组只能用一次，取出数据后空间不可用。可以改进成环形数组。 造轮子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ArrayQueue { private int maxSize;//数组最大容量 private int front;//队列头部 private int rear;//队列尾部 private int[] arr;//存放数据模拟队列 //初始化 public ArrayQueue(int maxSize){ this.maxSize = maxSize; arr = new int[maxSize]; front = -1;//队列头部前一个位置 rear = -1;//队列尾部 } //判断队列是否满 public boolean isFull(){ return rear == maxSize - 1; } //判断队列是否为空 public boolean isEmpty(){ return rear == front; } //添加值 public void addQueue(int n){ if(isFull()){ System.out.println(&quot;no available space in queue &quot;); return; } rear++; arr[rear] = n; } //取值 public int getQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;queue empty&quot;); } front++; return arr[front]; } //显示队列 public void viewQueue(){ if(isEmpty()){ System.out.println(&quot;empty queue&quot;); return; } for(int x : arr){ System.out.println(x); } } //查看头部 public int headQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;empty queue&quot;); } return arr[front + 1]; }} 环形数组队列实际上并没有实际的环形，对代码进行处理便可以实现虚拟环形。 思路 front 指向队列第一个元素，初始值为0。 rear 指向队列最后一个元素的后一个位置，预留一个位置作判断，初始值为0。 (rear + 1)%maxSize == front ，队列为满.利用remainder查看虚拟环形下一个位置。 remainder 实际作用是让指针在规定区间移动，达到虚拟环绕效果4. rear = front ,队列为空5. 有效数据个数，(rear-front+maxSize)%maxSize 造轮子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class CircleArrayQueue { private int maxSize;//数组最大容量 private int front;//队列头部 private int rear;//队列尾部 private int[] arr;//存放数据模拟队列 //初始化 public CircleArrayQueue(int maxSize){ this.maxSize = maxSize; arr = new int[maxSize]; } //判断队列是否满 public boolean isFull(){ return (rear + 1)%maxSize == front; } //判断队列是否为空 public boolean isEmpty(){ return rear == front; } //添加值 public void addQueue(int n){ if(isFull()){ System.out.println(&quot;no available space in queue &quot;); return; } arr[rear] = n; //remainder,超出范围往前跳 rear = (rear + 1) % maxSize; } //取值 public int getQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;queue empty&quot;); } int temp = arr[front]; front = (front + 1)%maxSize; return temp; } //显示队列 public void viewQueue(){ if(isEmpty()){ System.out.println(&quot;empty queue&quot;); return; } for(int i = front;i&lt;front+size();i++){ System.out.println(&quot;arr[&quot;+i%maxSize+&quot;]= &quot;+arr[i%maxSize] ); } } public int size(){ return (rear - front +maxSize)%maxSize; } //查看头部 public int headQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;empty queue&quot;); } return arr[front]; } 链表队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// A linked list (LL) node to store a queue entry class QNode { int key; QNode next; // constructor to create a new linked list node public QNode(int key) { this.key = key; this.next = null; } } // A class to represent a queue // The queue, front stores the front node of LL and rear stores the // last node of LL class Queue { QNode front, rear; public Queue() { this.front = this.rear = null; } // Method to add an key to the queue. void enqueue(int key) { // Create a new LL node QNode temp = new QNode(key); // If queue is empty, then new node is front and rear both if (this.rear == null) { this.front = this.rear = temp; return; } // Add the new node at the end of queue and change rear this.rear.next = temp; this.rear = temp; } // Method to remove an key from queue. void dequeue() { // If queue is empty, return NULL. if (this.front == null) return; // Store previous front and move front one node ahead QNode temp = this.front; this.front = this.front.next; // If front becomes NULL, then change rear also as NULL if (this.front == null) this.rear = null; } }","link":"/Reinventing-the-wheel/2020/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"},{"title":"稀疏数组 sparse array","text":"概述在一个数组里有多个同值的单元时，可以用稀疏数组进行压缩，只保留有效数字。也就是说在数据稀少的情况下才有优势。 举个栗子下图二维数组里，大多数都是0，真正有意义的数字只有5个。存那么多零岂不是浪费空间？ 因此我们可以根据对应的行列，只存储有效数值。注意:第一部分存储总行列数和有效值个数，以便于复原时创建数组。 二维转稀数思路1.遍历二维数组，得到有效值数量sum2.根据sum创建稀数组，spareArr int[sum+1][列]3.将有效数值存入稀数组 稀数转二维思路1.读取第一行数据后创建二维数组2.继续读取数据，存入二维数组 造轮子！！我们可以来看一下稀数数组在五子棋的应用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//五子棋游戏//创建11*11的二维数组//0：无棋子 1：黑子 2：蓝子int chessArr1[][] = new int[11][11];chessArr1[1][2] = 1;chessArr1[2][3] = 2;//输出棋盘System.out.println(&quot;棋盘&quot;);for(int[] row : chessArr1){ for(int data : row){ System.out.printf(&quot;%d\\t&quot;,data); } System.out.println();}//遍历数组得到有效值个数int sum = 0;for(int i = 0;i &lt; 11;i++){ for(int j = 0;j &lt; 11;j++){ if(chessArr1[i][j] != 0){ sum++; } }}//创建稀数数组int sparseArr[][] = new int[sum+1][3];sparseArr[0][0] = 11;sparseArr[0][1] = 11;sparseArr[0][2] = sum;//存入数据int count = 0;for(int i = 0;i &lt; 11;i++){ for(int j = 0;j &lt; 11;j++){ if(chessArr1[i][j] != 0){ count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } }}System.out.println(&quot;稀疏数组&quot;);for(int i = 0;i&lt;sparseArr.length;i++){ System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);}//恢复int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];for(int i =1;i&lt;sparseArr.length;i++){ chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];}//打印出来System.out.println(&quot;棋盘&quot;);for(int[] row : chessArr1){ for(int data : row){ System.out.printf(&quot;%d\\t&quot;,data); } System.out.println();} 最后输出的效果图是这样的","link":"/Reinventing-the-wheel/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"},{"title":"数据结构 简介","text":"简介数据结构是存储、组织数据的方式。它包含三方面的内容，逻辑关系、存储关系及操作。可分为线性结构和非线性结构。 线性结构数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。 [稀疏数组] 存储结构顺序存储结构：一组地址连续的存储单元依次存储线性表的各个数据元素链式存储结构：一组任意的存储单元来存储线性表的数据元素，这些单元可以分散在内存中的任意位置 非线性结构各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图","link":"/Reinventing-the-wheel/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%80%E4%BB%8B/"},{"title":"跳转查找 Jump search","text":"图解 使用已排序数组是这个算法的先前条件。从左边开始每次跳过一定的长度，如果发现搜寻的数字在上一个跳过的数据里再往回用线性搜索。 造轮子！！123456789101112131415161718192021222324252627282930313233343536public int jumpSearch(int[] arr, int x) { int n = arr.length; // Finding block size to be jumped int step = (int)Math.floor(Math.sqrt(n)); // Finding the block where element is // present (if it is present) int prev = 0; while (arr[Math.min(step, n)-1] &lt; x) { prev = step; step += (int)Math.floor(Math.sqrt(n)); if (prev &gt;= n) return -1; } // Doing a linear search for x in block // beginning with prev. while (arr[prev] &lt; x) { prev++; // If we reached next block or end of // array, element is not present. if (prev == Math.min(step, n)) return -1; } // If element is found if (arr[prev] == x) return prev; return -1; } 复杂度分析123456789101112时间： 假设每次跳跃m 最坏情况：跳n/m次，然后再往回查询m-1 k = n/m + m - 1 最差复杂性： O(sqrt(n))空间： 复杂性： O(1) 未完类似方法 指数搜索 (Exponential Search)其它Fibonacci SearchThe Ubiquitous Binary Search","link":"/Reinventing-the-wheel/2020/02/12/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E8%B7%B3%E8%BD%AC%E6%9F%A5%E6%89%BE/"},{"title":"二分查找 Binary search","text":"图解 使用已排序数组是这个算法的先前条件，该方法每次将数据对半分进行查询。 迭代法 Iterative来造轮子！！ 12345678910111213141516public int binarySearch(int array[], int target){ int left = 0; int right = array.length-1; while(left &lt;= right){ int mid = left + (right - left) / 2; if(array[mid] == target){ return mid; }else if(target &lt; array[mid]){ right = mid -1; }else { left = mid + 1; } } return -1; } 思路定义head，tail，mid，根据mid大小移动head 和 tail。 sudo code1234567两个变量记录头和尾while 头 &lt;= 尾 定义 mid ： 1. mid = target , return mid 2. mid &gt;target , 尾左移 3. Mid &lt; target，头右移数组查找完毕，return -1 复杂度分析12345678910111213时间： n/2,n/4,n/6…. ---&gt; n/2^k 最坏情况：n/2^k = 1 2^k = n K = log n 最差复杂性： O(log n) 平均复杂性： O(log n)空间： 复杂性： O(1) 递归法 Recursive来造轮子！！ 123456789101112131415161718192021222324public int binarySearch(int arr[], int l, int r, int x) { if (r &gt;= l) { int mid = l + (r - l) / 2; // If the element is present at the // middle itself if (arr[mid] == x) return mid; // If element is smaller than mid, then // it can only be present in left subarray if (arr[mid] &gt; x) return binarySearch(arr, l, mid - 1, x); // Else the element can only be present // in right subarray return binarySearch(arr, mid + 1, r, x); } // We reach here when element is not present // in array return -1; } 未完类似方法 插值搜索 (Interpolation search)","link":"/Reinventing-the-wheel/2020/02/08/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"KMP算法","text":"简介 kmp算法也称为字符串查找算法，可以确认当前字符串中是否包含目标字符串。 当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 暴力解法在深入了解KMP之前我们需要了解暴力解法。话不多说先上图！ 首先我们从T[0]开始和P比较，直到T[3] 和 P[3] 不匹配。然后从T[1]开始重新和P比较。 这时T[1] 不匹配 P[1]，从T[2]开始重新和P比较. 以此类推直到找到第一组存在的目标。这时如果T数组还有多余长度可以继续往下搜寻。但当前T数组已经比较完，此时结束查找。 暴力的负面效果在某些情况下暴力解法效率极低，我们再来看一个列子。 在这种情况下每次不匹配只会发生在P[4], 也就是说每次第5位出错前我们会经历很多次的无意义比较。这样会导致效率低下，而kmp很好得解决了这个问题。 前缀表(prefix table)首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 部分匹配值 就是”前缀”和”后缀”的最长的共有元素的长度。 前缀表实际应用直接跳过了重复的部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void KMPSearch(String pat, String txt) { int M = pat.length(); int N = txt.length(); // create lps[] that will hold the longest // prefix suffix values for pattern int lps[] = new int[M]; int j = 0; // index for pat[] // Preprocess the pattern (calculate lps[] // array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] while (i &lt; N) { if (pat.charAt(j) == txt.charAt(i)) { j++; i++; } if (j == M) { System.out.println(&quot;Found pattern &quot; + &quot;at index &quot; + (i - j)); j = lps[j - 1]; } // mismatch after j matches else if (i &lt; N &amp;&amp; pat.charAt(j) != txt.charAt(i)) { // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j - 1]; else i = i + 1; } } } public void computeLPSArray(String pat, int M, int lps[]) { // length of the previous longest prefix suffix int len = 0; int i = 1; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 while (i &lt; M) { if (pat.charAt(i) == pat.charAt(len)) { len++; lps[i] = len; i++; } else // (pat[i] != pat[len]) { // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) { len = lps[len - 1]; // Also, note that we do not increment // i here } else // if (len == 0) { lps[i] = len; i++; } } } } 复杂度分析平均复杂性： O(log n)未完","link":"/Reinventing-the-wheel/2020/02/06/%E7%AE%97%E6%B3%95/KMP/"},{"title":"线性查找 Linear search","text":"图解 这种方法太过于暴力，从左到右依次查询，相比于其他算法性能较差。 但优点在于可以对无序数组直接进行查询（你先排序再用二分不是更香？）。不过基本上也不会怎么用到啦~~~ 迭代法 Iterative来造轮子！！ 12345678910public int search(int arr[], int x) { int n = arr.length; for (int i = 0; i &lt; n; i++) { if (arr[i] == x) return i; } return -1; } 复杂度分析最差复杂性： O(n)平均复杂性： O(n)空间复杂性： O(1)","link":"/Reinventing-the-wheel/2020/02/01/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"简介","slug":"简介","link":"/Reinventing-the-wheel/tags/%E7%AE%80%E4%BB%8B/"},{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/tags/JVM/"},{"name":"书籍阅读","slug":"书籍阅读","link":"/Reinventing-the-wheel/tags/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/Reinventing-the-wheel/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"JVM","slug":"JVM","link":"/Reinventing-the-wheel/categories/JVM/"},{"name":"JVM 简介","slug":"JVM/JVM-简介","link":"/Reinventing-the-wheel/categories/JVM/JVM-%E7%AE%80%E4%BB%8B/"},{"name":"算法","slug":"算法","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"算法/查找","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"},{"name":"KMP","slug":"算法/KMP","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/KMP/"},{"name":"数据结构","slug":"数据结构","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"①简介","slug":"数据结构/①简介","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E2%91%A0%E7%AE%80%E4%BB%8B/"},{"name":"排序","slug":"算法/排序","link":"/Reinventing-the-wheel/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"线性结构","slug":"数据结构/线性结构","link":"/Reinventing-the-wheel/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]}